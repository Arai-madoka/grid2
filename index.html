<!DOCTYPE html>
<html>
<head>
    <title>grid2/VR</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <link type="text/css" rel="stylesheet" href="main.css">
</head>
<body>
<script type="module">
    import * as THREE from 'https://unpkg.com/three@0.126.1/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.126.1/examples/jsm/controls/OrbitControls.js';
    import { VRButton } from 'https://unpkg.com/three@0.126.1/examples/jsm/webxr/VRButton.js';
    import { TubePainter } from 'https://unpkg.com/three@0.126.1/examples/jsm/misc/TubePainter.js';
    
    let camera,scene,renderer;
    let dirLight;
    const cursor = new THREE.Vector3();
    let controller1, controller2;
    
    init();
    animate();
 
    function init() {
        //シーンの作成
        scene = new THREE.Scene();
        scene.background = new THREE.Color( 0x222222 );
        //カメラの作成
        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        //カメラセット
        camera.position.set(20, 30, 50);
        //光源
        dirLight = new THREE.SpotLight(0xffffff,1.5);//color,強度
        dirLight.position.set(-30, 40, 30);
        scene.add(dirLight);
        
        const floorGometry = new THREE.PlaneGeometry( 4, 4 );
		const floorMaterial = new THREE.MeshStandardMaterial( {
				color: 0x222222,
				roughness: 1.0,
				metalness: 0.0
			} );
        const floor = new THREE.Mesh( floorGometry, floorMaterial );
	floor.rotation.x = - Math.PI / 2;
	scene.add( floor );
        //ペイント
        const painter1 = new TubePainter();
	scene.add( painter1.mesh );
	const painter2 = new TubePainter();
	scene.add( painter2.mesh );
        
        //レンダラー
        renderer = new THREE.WebGLRenderer();
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.xr.enabled = true; // レンダラーのXRを有効化
        //document.body.appendChild(renderer.domElement);
        document.body.appendChild(VRButton.createButton(renderer));
        
        // 滑らかにカメラコントローラーを制御する
        const controls = new OrbitControls(camera, document.body);
        //controls.enableDamping = true;
        //controls.dampingFactor = 0.2;
	controls.target.set( 0, 1.6, 0 );
	controls.update();
 
        // グリっド表示
        const gridHelper = new THREE.GridHelper(10,5) //大きさ・分割数・センタラインcolor・マスカラ―
        scene.add(gridHelper);
        
        //コントローラー
        function onSelectStart() {
				this.userData.isSelecting = true;
				}
		function onSelectEnd() {
				this.userData.isSelecting = false;
				}
		function onSqueezeStart() {
				this.userData.isSqueezing = true;
				this.userData.positionAtSqueezeStart = this.position.y;
				this.userData.scaleAtSqueezeStart = this.scale.x;
				}
		function onSqueezeEnd() {
				this.userData.isSqueezing = false;
				}
        controller1 = renderer.xr.getController( 0 );
		controller1.addEventListener( 'selectstart', onSelectStart );
		controller1.addEventListener( 'selectend', onSelectEnd );
		controller1.addEventListener( 'squeezestart', onSqueezeStart );
		controller1.addEventListener( 'squeezeend', onSqueezeEnd );
		controller1.userData.painter = painter1;
		scene.add( controller1 );
		
        controller2 = renderer.xr.getController( 1 );
		controller2.addEventListener( 'selectstart', onSelectStart );
		controller2.addEventListener( 'selectend', onSelectEnd );
        controller2.addEventListener( 'squeezestart', onSqueezeStart );
		controller2.addEventListener( 'squeezeend', onSqueezeEnd );
		controller2.userData.painter = painter2;
		scene.add( controller2 );

        const geometry = new THREE.CylinderGeometry( 0.01, 0.02, 0.08, 5 );
		geometry.rotateX( - Math.PI / 2 );
		const material = new THREE.MeshStandardMaterial( { flatShading: true } );
		const mesh = new THREE.Mesh( geometry, material );
		const pivot = new THREE.Mesh( new THREE.IcosahedronGeometry( 0.01, 3 ) );
		pivot.name = 'pivot';
		pivot.position.z = - 0.05;
		mesh.add( pivot );

		controller1.add( mesh.clone() );
		controller2.add( mesh.clone() );

		window.addEventListener( 'resize', onWindowResize );

        //document.getElementById("WebGL-output").appendChild(renderer.domElement);
    }
    function onWindowResize() {
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		renderer.setSize( window.innerWidth, window.innerHeight );
    }
	function handleController( controller ) {
	    const userData = controller.userData;
		const painter = userData.painter;
		const pivot = controller.getObjectByName( 'pivot' );

		if ( userData.isSqueezing === true ) {
			const delta = ( controller.position.y - userData.positionAtSqueezeStart ) * 5;
			const scale = Math.max( 0.1, userData.scaleAtSqueezeStart + delta );
			pivot.scale.setScalar( scale );
            painter.setSize( scale );
			}
        cursor.setFromMatrixPosition( pivot.matrixWorld );
		if ( userData.isSelecting === true ) {
			painter.lineTo( cursor );
			painter.update();
			} else {
			painter.moveTo( cursor );
			}
    }
      function animate() {
				renderer.setAnimationLoop( render );
			}
        function render() {
				handleController( controller1 );
				handleController( controller2 );
				renderer.render( scene, camera );
			}
</script>
</body>
    </html>
